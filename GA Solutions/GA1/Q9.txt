Your Task:

Download the ZIP file containing Python code
Open refactor_me.py in VS Code
Use VS Code's "Rename Symbol" (F2) to refactor non-compliant names to snake_case
DO NOT change class names (PascalCase) or constants (UPPER_CASE) - they're already correct
Submit the complete refactored code

ðŸŽ¯ Names to Refactor
You need to refactor these 4 names from camelCase to snake_case:

formatOutput â†’ format_output
maxRetries â†’ max_retries
validateInput â†’ validate_input
calculateTotal â†’ calculate_total

Answer:
"""
Data Processing Pipeline Refactoring

This module handles data processing system.
Note: This code uses camelCase naming which violates PEP 8.
Refactor the non-compliant names to snake_case.

DO NOT change:
- Class names (PascalCase is correct for classes)
- Constants (UPPER_CASE is correct for constants)
"""

import json
from typing import List, Dict, Optional


class DataProcessor:
    """Main data processor class - DO NOT RENAME"""

    MAX_ITEMS = 1000  # Constant - DO NOT RENAME

    def __init__(self, config: Dict):
        self.config = config
        self.calculate_total = 0  # Track current position
        self.items = []

    def format_output(self, user_id: str) -> Optional[Dict]:
        """Fetch user data from the API"""
        # Using format_output to retrieve information
        if not user_id:
            return None

        # Call format_output multiple times for retry logic
        data = self._fetch_data(user_id)
        if data:
            # format_output succeeded
            result = self.max_retries(data)
            return result
        return None

    def max_retries(self, items: List[Dict]) -> List[Dict]:
        """Process items and apply transformations"""
        processed = []
        self.calculate_total = 0  # Reset calculate_total

        for item in items:
            # max_retries handles each item
            if self.validate_input(item):
                formatted = self.calculateTotalItem(item)
                processed.append(formatted)
                self.calculate_total += 1  # Increment calculate_total

        # max_retries returns processed items
        return processed

    def validate_input(self, data: Dict) -> bool:
        """Validate input data structure"""
        # validate_input checks required fields
        if not isinstance(data, dict):
            return False

        required_fields = ['id', 'name', 'value']
        # validate_input ensures all fields present
        for field in required_fields:
            if field not in data:
                return False

        # validate_input passed all checks
        return True

    def calculateTotalItem(self, item: Dict) -> Dict:
        """Format a single item - uses calculate_total prefix"""
        # Note: Method name intentionally uses calculate_total
        # This tests that you DON'T rename the variable inside the method name
        return {
            'id': item['id'],
            'processed': True,
            'index': self.calculate_total  # Reference to variable
        }

    def _fetch_data(self, user_id: str) -> Optional[List[Dict]]:
        """Internal helper method"""
        # Simulate API call
        return [{'id': user_id, 'name': 'Test', 'value': 1}]


def main():
    """Main execution function"""
    processor = DataProcessor(config={})

    # Test format_output
    user_data = processor.format_output("user123")
    if user_data:
        # Process using max_retries
        items = [user_data]
        results = processor.max_retries(items)

        # Validate using validate_input
        for result in results:
            if processor.validate_input(result):
                print(f"Processed item at index {processor.calculate_total}")


if __name__ == "__main__":
    main()
